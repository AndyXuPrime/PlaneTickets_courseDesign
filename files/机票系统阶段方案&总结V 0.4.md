## 1. 总体架构演进
项目已成功从传统的 Spring Boot 单体应用转型为基于 **Maven 多模块**管理的微服务架构。

*   **父工程 (`plane-ticket-cloud`)**：统一管理 Spring Boot (3.2.5), Spring Cloud (2023.0.x), Spring Cloud Alibaba (2023.0.1.0) 的版本依赖 (BOM)。
*   **服务拆分**：
    *   **基础服务**：`gateway-service` (网关), `auth-service` (认证 - 开发中)。
    *   **业务服务**：`flight-service` (航班资源), `order-service` (订单交易 - 待开发), `admin-service` (后台管理 - 待开发)。
    *   **公共模块**：`common-module` (共享依赖)。
*   **中间件集成**：
    *   **Nacos**：作为注册中心 (Service Discovery) 和配置中心 (Config Management)。
    *   **Redis**：作为分布式缓存，加速查询。
    *   **MinIO**：作为对象存储，处理图片上传。

---

## 2. 数据库重构与优化 (MySQL)
为了适应微服务“高内聚、低耦合”的特性，并支持后台管理的多角色需求，对数据库进行了深度改造：

1.  **用户表升级 (`customers` -> `users`)**：
    *   **改动**：重命名表，主键改为 `user_id`。
    *   **新增**：引入 `role` (普通用户/平台管理员/航司管理员)、`status` (审核状态)、`airline_code` (归属航司) 字段。
    *   **目的**：支持 RBAC 权限模型和航司入驻审核流程。
2.  **库存解耦 (`daily_flight_stock`)**：
    *   **新增**：创建每日库存表。
    *   **目的**：解决 `flight-service` 查询余票必须跨库连接 `order-service` 订单表的耦合问题，提升查询性能。
3.  **数据规范化 (`airports`)**：
    *   **新增**：机场三字码字典表。
    *   **目的**：规范化城市与机场的对应关系，支持前端下拉选择。
4.  **外键一致性**：将 `tickets` 表中的 `customer_id` 修正为 `user_id`，确保 JPA 关联映射正确。

---

## 3. 已完成的功能模块

### 3.1 公共模块 (`common-module`)
*   **功能**：封装了系统通用的 DTO (如 `FlightSearchVO`, `LoginRequest`)、枚举 (`CabinClass`, `UserRole`)、全局异常处理 (`GlobalExceptionHandler`) 以及 JWT 工具类 (`JwtTokenProvider`)。
*   **验证**：成功被 Gateway 和 Flight 服务引用，解决了代码重复问题。

### 3.2 网关服务 (`gateway-service`)
*   **核心功能**：
    *   **动态路由**：基于 Nacos 自动发现服务，配置了 `/api/flights/**` 转发至 `flight-service`，`/api/auth/**` 转发至 `auth-service`。
    *   **全局鉴权**：实现了基于 WebFlux 的 `AuthGlobalFilter`。
    *   **JWT 解析**：拦截请求头 `Authorization`，校验 Token 合法性，并将解析出的 `X-User-Name` 传递给下游服务。
    *   **白名单机制**：放行登录、注册及航班搜索接口。

### 3.3 航班服务 (`flight-service`)
*   **核心功能**：
    *   **航班查询**：支持按“航线 (出发地-目的地)”和“航空公司”两种模式搜索。
    *   **动态定价 (`PricingStrategy`)**：重构了定价逻辑。
        *   **改动**：移除了对 `TicketRepository` 的直接依赖。
        *   **优化**：改为通过接口参数传入 `soldSeats` (已售座位)，实现了计算逻辑与数据存储的解耦。
    *   **图片上传**：集成了 MinIO SDK，实现了航司 Logo 的上传与 URL 生成。
    *   **性能优化**：集成了 Redis 缓存。

---

## 4. 遇到的困难与详细解决方案 (Troubleshooting)

这是重构过程中最具价值的部分，我们解决了一系列典型的微服务集成问题。

### 🔴 问题一：Maven 依赖与构建地狱
*   **现象**：`gateway-service` 启动报错 `package com.bighomework.common.security does not exist`，或者父子工程 `pom.xml` 报错。
*   **原因**：
    1.  父工程 `pom.xml` 错误地包含了子模块的依赖代码。
    2.  `common-module` 代码移动后，Java 文件内的 `package` 声明未修改。
    3.  修改了 Common 代码，但未更新本地 Maven 仓库。
*   **解决**：
    1.  **重写 POM**：严格区分父工程 (管理版本) 和子模块 (引入依赖) 的职责。
    2.  **修正包名**：将 `planeTicketWeb` 统一批量替换为 `common` 或 `flight`。
    3.  **强制安装**：在根目录执行 `mvn clean install -DskipTests`，确保“货”被正确送入本地仓库，让其他服务能引用到最新代码。

### 🔴 问题二：Gateway 技术栈冲突
*   **现象**：Gateway 启动失败，或者过滤器不生效。
*   **原因**：原有的 `JwtAuthenticationFilter` 是基于 Servlet (Tomcat) 的，而 Spring Cloud Gateway 基于 WebFlux (Netty)。两者底层模型不兼容。
*   **解决**：
    1.  **删除旧代码**：移除了 `security` 包下的 Servlet 过滤器。
    2.  **重写过滤器**：编写了实现 `GlobalFilter` 接口的 `AuthGlobalFilter`，使用响应式编程处理请求。
    3.  **排除依赖**：在 `gateway-service` 的 `pom.xml` 中，引用 `common-module` 时显式排除了 `spring-boot-starter-web`。

### 🔴 问题三：Nacos 连接与配置加载失败
*   **现象**：应用启动报错 `Failed to configure a DataSource`，日志显示 `Connection refused ... 9848`。
*   **原因**：
    1.  Nacos 2.x 客户端需要连接 gRPC 端口 (9848)，本地环境可能被防火墙拦截或端口未开放。
    2.  由于连不上 Nacos，应用无法拉取配置文件，导致没有数据库 URL，从而引发 JPA 自动配置失败。
    3.  数据库 Schema 名称不一致 (`plane_ticket_db` vs `planetickets`)。
*   **解决**：
    1.  确保 Nacos 以 `standalone` 模式启动。
    2.  修正 Nacos 中的 YAML 配置，将数据库名改为实际的 `planetickets`。
    3.  在本地 `bootstrap.yml` 中仅保留 Nacos 地址配置，确保应用能先找到 Nacos。

### 🔴 问题四：Redis 缓存失效与序列化异常
*   **现象 1**：接口返回成功，但 Redis 中 `keys *` 为空。
    *   **原因**：Spring Boot 默认未强制指定缓存类型，降级使用了内存缓存。
    *   **解决**：在 Nacos 配置中添加 `spring.cache.type: redis`，并在启动类添加 `@EnableCaching`。
*   **现象 2**：强制使用 Redis 后，接口报 500 错误。
    *   **原因**：`FlightSearchVO` 包含 Java 8 的 `LocalDate` 类型，Redis 默认的 JDK 序列化或普通的 JSON 序列化无法处理该类型。
    *   **解决**：编写 `RedisConfig`，自定义 `ObjectMapper`，注册 `JavaTimeModule`，并禁用“写为时间戳”功能，实现了清晰的 JSON 存储。

---

## 5. 当前项目状态

*   ✅ **基础设施**：Nacos、Redis、MinIO 环境均已调通。
*   ✅ **全链路打通**：
    *   前端请求 -> Gateway (路由) -> Flight Service (业务处理) -> Redis (未命中) -> MySQL (查询) -> 返回数据。
    *   前端请求 -> Gateway -> Flight Service -> Redis (命中) -> 直接返回数据。
*   ✅ **数据验证**：通过 Postman 和前端页面验证，搜索“北京首都国际机场-成都天府国际机场”能正确返回 JSON 数据，且 Redis 中生成了对应的 Key。

**接下来的重点**：
全力攻克 **`auth-service`**，解决登录接口的 500 报错（通过补充 JWT 配置），打通 Token 生成环节，从而为订单服务的开发扫清障碍。